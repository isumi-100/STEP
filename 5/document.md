#### コードの説明

2-opt 法をもとに実装した。two*opt 関数を追加した以外は github にすでにあった solver*?.py とほぼ同じである。

以下、two_opt 関数の説明をする。
while 文の終了条件は`improved == False`、すなわちエッジの入れ替えがなくなることまたは while 文の繰り返し回数 n について`n > 300`があ成り立つことである。

一般的な 2-opt 法に基づいて、4 点に関して辺を組み替えた方が短ければ入れ替える。
また、そうでない場合については次の通りである。

1. 0-1 の範囲の乱数 x を生成する
2. エッジを組み替えた場合と組み替えない場合とで生じる差を y としたとき、`z = e^(-0.1*y)`とする。(※)
3. x < z が成り立つ場合は辺の組み換えを行う。

※について、z をこのように定めた理由は、 まず x が 0≤x≤1 を満たすため、z もこの条件を満たすべきである。また、y が大きいほど「組み換えを行う前の方が組み替えた場合よりも短い」ということなので、それでも入れ替えを行う確率 z は小さい方がよい。
そのため、当初はこれらの条件を満たす`z = e^(-y)`とした。これでは、交差した状態の辺が多く生じており、必ずしも交差しないほうが良いとは限らないが、visualizer で見た感じ明らかに交差しすぎだったため、基本的に z をさらに小さくするために 0.1 を設定してみた。
